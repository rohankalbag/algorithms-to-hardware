$parameter ORDER 16

$storage A B C: $array[ORDER][ORDER] $of $uint<32>

$module [storeA] $in (I J: $uint<8> wval: $uint<32>) $out () $is
{
	A[I][J] := wval
}
$module [storeB] $in (I J: $uint<8> wval: $uint<32>) $out () $is
{
	B[I][J] := wval
}

$module [loadC] $in (I J : $uint<8>) $out (Y : $uint<32>) $is
{
	Y := C[I][J]
}


$module [dot_product] $in (I J: $uint<8>) $out (result: $uint<32>) $is
{
	K := $zero<8>

	$volatile nK := (K + 16)
	$volatile K1 := (K + 1)
	$volatile K2 := (K + 2)
	$volatile K3 := (K + 3)
	$volatile K4 := (K + 4)
	$volatile K5 := (K + 5)
	$volatile K6 := (K + 6)
	$volatile K7 := (K + 7)
	$volatile K8 := (K + 8)
	$volatile K9 := (K + 9)
	$volatile K10 := (K + 10)
	$volatile K11 := (K + 11)
	$volatile K12 := (K + 12)
	$volatile K13 := (K + 13)
	$volatile K14 := (K + 14)
	$volatile K15 := (K + 15)
	
	R0 := (A[I][K] * B[K][J])
	R1 := (A[I][K1] * B[K1][J])
	R2 := (A[I][K2] * B[K2][J])
	R3 := (A[I][K3] * B[K3][J])
	R4 := (A[I][K4] * B[K4][J])
	R5 := (A[I][K5] * B[K5][J])
	R6 := (A[I][K6] * B[K6][J])
	R7 := (A[I][K7] * B[K7][J])
	R8 := (A[I][K8] * B[K8][J])
	R9 := (A[I][K9] * B[K9][J])
	R10 := (A[I][K10] * B[K10][J])
	R11 := (A[I][K11] * B[K11][J])
	R12 := (A[I][K12] * B[K12][J])
	R13 := (A[I][K13] * B[K13][J])
	R14 := (A[I][K14] * B[K14][J])
	R15 := (A[I][K15] * B[K15][J])
	result := ((((R0 + R1) + (R2 + R3)) + ((R4 + R5) + (R6 + R7))) + (((R8 + R9) + (R10 + R11)) + ((R12 + R13) +(R14 + R15))))
}

$module [mmul] $in () $out () $is
{
	$branchblock[loop] {
	    $merge $entry I_loopback 
			$phi I := $zero<8> $on $entry nI $on I_loopback
		$endmerge
		$volatile nI := (I + 1)

		$dopipeline $depth 32 $fullrate 
			$merge $entry $loopback 
				$phi J := $zero<8> $on $entry nJ $on $loopback
			$endmerge
			$volatile nJ := (J + 1)
			$volatile continue_flag := (J < (ORDER - 1))
	
			C[I][J] := ($call dot_product (I J))
	
		$while continue_flag

	    $if (I < (ORDER-1)) $then $place [I_loopback] $endif
	}
}

