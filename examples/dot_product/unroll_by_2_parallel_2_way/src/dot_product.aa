$storage A B: $array[256] $of $float<8,23>

$module [storeA] $in (addr: $uint<8> wval: $float<8,23>) $out () $is
{
	A[addr] := wval
}
$module [storeB] $in (addr: $uint<8> wval: $float<8,23>) $out () $is
{
	B[addr] := wval
}

$module [dot_product] $in (order: $uint<8>) $out (result: $float<8,23>) $is
{
	
	// divide by 2.
	order_by_2 := ($concat $zero<1> ($slice order 7 1))

	$parallelblock[par] {
		$branchblock[loop0] {
		    $dopipeline $depth 31 $fullrate
			$merge $entry $loopback
				$phi I := $zero<8> $on $entry nI $on $loopback
				$phi SUM0 := ($bitcast ($float<8,23>) 0)  $on $entry nSUM0 $on $loopback
				$phi SUM1 := ($bitcast ($float<8,23>) 0)  $on $entry nSUM1 $on $loopback
			$endmerge
			$volatile nI := (I + 2)
			$volatile continue_flag := (I < (order_by_2-2))
			$volatile I1 := (I + 1)

			nSUM0 := (SUM0 + (A[I] * B[I]))
			nSUM1 := (SUM1 + (A[I1] * B[I1]))

		    $while continue_flag
		    R := (nSUM0 + nSUM1)
	       } (R => R0)
	       $branchblock[loop1] {
		    $dopipeline $depth 31 $fullrate
			$merge $entry $loopback
				$phi I := order_by_2 $on $entry nI $on $loopback
				$phi SUM0 := ($bitcast ($float<8,23>) 0)  $on $entry nSUM0 $on $loopback
				$phi SUM1 := ($bitcast ($float<8,23>) 0)  $on $entry nSUM1 $on $loopback
			$endmerge
			$volatile nI := (I + 2)
			$volatile continue_flag := (I < (order-2))
			$volatile I1 := (I + 1)

			nSUM0 := (SUM0 + (A[I] * B[I]))
			nSUM1 := (SUM1 + (A[I1] * B[I1]))

		    $while continue_flag
		    R := (nSUM0 + nSUM1)
	       } (R => R1)      // end branchblock loop1
	} (R0 => Rx0 R1 => Rx1) // end parallel block par
     
	$volatile result := (Rx0 + Rx1)
}


