$storage A: $array [32][32] $of $uint<32>

$module [store] $in (addr0 addr1: $uint<8>  wdata: $uint<32>) $out () $is
{
	A[addr0][addr1] := wdata
}

$module [load] $in (addr0 addr1 : $uint<8>) $out (rdata : $uint<32>) $is
{
	rdata := A[addr0][addr1]
}


$module [init_mem] $in (addr0min addr0max addr1min addr1max: $uint<8> 
					fill_value: $uint<32>) $out () $is
{
	$branchblock[loop] {

		$merge $entry loopback_outer
			$phi I := addr0min $on $entry nI $on loopback_outer
		$endmerge

			$merge $entry loopback_inner
				$phi J := addr1min $on $entry nJ $on loopback_inner
			$endmerge

			A[I][J] := fill_value
			$volatile nJ := (J + 1)

			$if (J < addr1max) $then
				$place [loopback_inner]
			$endif

		$volatile nI := (I + 1)


		$if (I < addr0max) $then
			$place [loopback_outer]
		$endif
	} 
}

$module [max_in_range] $in (addr0min addr0max addr1min addr1max: $uint<8>) 
				$out (maxval : $uint<32>) $is
{
	$branchblock[loop] {

		$merge $entry loopback_outer
			$phi I := addr0min $on $entry nI $on loopback_outer
			$phi M_outer := $zero<32> $on $entry nM_outer $on loopback_outer
		$endmerge
			$merge $entry loopback_inner
				$phi J := addr1min $on $entry nJ $on loopback_inner
				$phi M_inner := M_outer $on $entry nM_inner $on loopback_inner
			$endmerge

			nJ := (J + 1)
			t := A[I][J]
			
			nM_inner := ($mux (t > M_inner) t M_inner)

			$if (J < addr1max) $then
				$place [loopback_inner]
			$endif

		nI := (I + 1)
		nM_outer := ($mux (nM_inner > M_outer) nM_inner M_outer)

		$if (I < addr0max) $then
			$place [loopback_outer]
		$endif

	}  (nM_outer => nM)

	maxval := nM
}

