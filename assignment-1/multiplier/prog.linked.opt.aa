$module [global_storage_initializer_]
$in ()
$out ()
$is
{
  $null
}
$module [shift_and_add_mul]
$in ( a : $uint<8>   b : $uint<8>  )
$out ( product : $uint<16>  )
$is
{
  $branchblock [loop]
  {
    $merge $entry loopback 
    $phi curr_a := 			  ($bitcast ($uint<16>) a ) $on   $entry 			  next_a $on   loopback 
    // type of target is $uint<16>
    $phi curr_b := 			  next_b $on   loopback 			  ($bitcast ($uint<16>) b ) $on   $entry 
    // type of target is $uint<16>
    $phi sum := 			  ($bitcast ($uint<16>) 0  ) $on   $entry 			  next_sum $on   loopback 
    // type of target is $uint<16>
    $phi count := 			  ($bitcast ($uint<16>) 0  ) $on   $entry 			  next_count $on   loopback 
    // type of target is $uint<16>
    $endmerge
    $volatile continue_flag := (curr_b != 0 ) $buffering 1
    $volatile add_shifted := ((curr_b & 1 ) != 0 ) $buffering 1
    $volatile shifted_sum := (sum + (curr_a << count)) $buffering 1
    next_count := (count + 1 ) $buffering 1// bits of buffering = 16. 
    next_sum := ( $mux add_shifted shifted_sum  sum )  $buffering 1// bits of buffering = 16. 
    next_a := curr_a $buffering 1// bits of buffering = 16. 
    next_b := (curr_b >> 1 ) $buffering 1// bits of buffering = 16. 
    $if continue_flag $then 
    $place[loopback]
    $else 
    product := sum $buffering 1// bits of buffering = 16. 
    $endif
  }
}
// use of gated clocks in modules 
