$module [global_storage_initializer_]
$in ()
$out ()
$is
{
  $null
}
$module [shift_and_add_mul]
$in ( a_in : $uint<8>   b_in : $uint<8>  )
$out ( product : $uint<16>  )
$is
{
  $branchblock [loop]
  {
    $merge $entry loopback 
    $phi a := 			  ($bitcast ($uint<16>) a_in ) $on   $entry 			  next_a $on   loopback 
    // type of target is $uint<16>
    $phi b := 			  next_b $on   loopback 			  ($bitcast ($uint<16>) b_in ) $on   $entry 
    // type of target is $uint<16>
    $phi sum := 			  ($bitcast ($uint<16>) 0  ) $on   $entry 			  next_sum $on   loopback 
    // type of target is $uint<16>
    $phi count := 			  ($bitcast ($uint<16>) 0  ) $on   $entry 			  next_count $on   loopback 
    // type of target is $uint<16>
    $endmerge
    $volatile continue_flag := (b != 0 ) $buffering 1
    $volatile add_shifted := ((b & 1 ) != 0 ) $buffering 1
    $volatile shifted_sum := (sum + (a << count)) $buffering 1
    next_count := (count + 1 ) $buffering 1// bits of buffering = 16. 
    next_sum := ( $mux add_shifted shifted_sum  sum )  $buffering 1// bits of buffering = 16. 
    next_a := a $buffering 1// bits of buffering = 16. 
    next_b := (b >> 1 ) $buffering 1// bits of buffering = 16. 
    $if continue_flag $then 
    $place[loopback]
    $else 
    product := sum $buffering 1// bits of buffering = 16. 
    $endif
  }
}
// use of gated clocks in modules 
